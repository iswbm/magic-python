# 1.31 如何像 awk一样分割字符串？

![](http://image.iswbm.com/20200804124133.png)

若你使用过 Shell 中的 awk 工具，会发现用它来分割字符串是非常方便的。特别是多个连续空格会被当做一个处理。

```shell
[root@localhost ~]# cat demo.txt 
hello      world
[root@localhost ~]# 
[root@localhost ~]# awk '{print$1,$2}' demo.txt 
hello world
```

可是转换到 Python 上面来呢？结果可能是这样的。

```python
>>> msg='hello    world'
>>> msg.split(' ')
['hello', '', '', '', 'world']
```

与我预想的结果不符，多个空格会被分割多次。

那有什么办法可以达到 awk 一样的效果呢？

有两种方法。

## 第一种方法

split函数不加参数，就能达到 awk 的效果

```python
>>> msg='hello    world'
>>> msg.split()
['hello', 'world']
```

其实不仅是空格，严格来说，只要是空字符（比如制表符、换行符），就可以使用

```python
>>> msg='hello \t \r\n world'
>>> msg.split()
['hello', 'world']
```

## 第二种方法

使用 filter 来辅助，这种适用于所有的分隔符，下面以 `-` 为分隔符来举例。

```python
>>> msg='hello----world'
>>> msg.split('-')
['hello', '', '', '', 'world']
>>> 
>>> filter(None, msg.split('-'))
['hello', 'world']
```

是不是很神奇，filter 印象中第一个参数接收的是 函数，这里直接传 None 居然有奇效。

查看了注释，原来是这个函数会适配 None 的情况，当第一个参数是None的时候，返回第二个参数（可迭代对象）中非空的值，非常方便。

![](http://image.iswbm.com/20200821173708.png)

换用函数的写法，可以这样

```python
>>> msg='hello----world'
>>> msg.split('-')
['hello', '', '', '', 'world']
>>>
>>> filter(bool, msg.split('-'))
['hello', 'world']
```





